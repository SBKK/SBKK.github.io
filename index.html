<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="THEWY">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="THEWY">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WY">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>THEWY</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">THEWY</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/17/apollo-canbus-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WY">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THEWY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/17/apollo-canbus-study/" class="post-title-link" itemprop="url">apollo canbus study</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-17 15:22:20 / Modified: 15:25:08" itemprop="dateCreated datePublished" datetime="2022-03-17T15:22:20+08:00">2022-03-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Autonomous-Driving/" itemprop="url" rel="index"><span itemprop="name">Autonomous Driving</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="canbus"><a href="#canbus" class="headerlink" title="canbus"></a>canbus</h1><h3 id="底层can"><a href="#底层can" class="headerlink" title="底层can"></a>底层can</h3><p>CanClient是底层can的抽象类，表示某一种can设备的接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CanClient</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> CANCardParameter &amp;parameter)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> apollo::<span class="function">common::ErrorCode <span class="title">Start</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> apollo::<span class="function">common::ErrorCode <span class="title">Send</span><span class="params">(<span class="type">const</span> std::vector&lt;CanFrame&gt; &amp;frames,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int32_t</span> *<span class="type">const</span> frame_num)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> apollo::<span class="function">common::ErrorCode <span class="title">Receive</span><span class="params">(std::vector&lt;CanFrame&gt; *<span class="type">const</span> frames,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int32_t</span> *<span class="type">const</span> frame_num)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>can client由工厂模式创建，不同参数指定不同 can client</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> can_factory = CanClientFactory::<span class="built_in">Instance</span>();</span><br><span class="line">can_factory-&gt;<span class="built_in">RegisterCanClients</span>();</span><br><span class="line">can_client_ = can_factory-&gt;<span class="built_in">CreateCANClient</span>(canbus_conf_.<span class="built_in">can_card_parameter</span>());</span><br></pre></td></tr></table></figure>

<p>以socket为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SocketCanClientRaw</span> : <span class="keyword">public</span> CanClient</span><br></pre></td></tr></table></figure>

<p>继承了CanClient，实现了其中的虚函数，主要就是调用linux原生的socket api</p>
<h3 id="底盘数据抽象"><a href="#底盘数据抽象" class="headerlink" title="底盘数据抽象"></a>底盘数据抽象</h3><p>不同车辆底盘数据、协议不同，使用了vehicle factory来创建不同车辆的 factory</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VehicleFactory vehicle_factory;</span><br><span class="line">vehicle_factory.<span class="built_in">RegisterVehicleFactory</span>();</span><br><span class="line"><span class="keyword">auto</span> vehicle_object =</span><br><span class="line">    vehicle_factory.<span class="built_in">CreateVehicle</span>(canbus_conf_.<span class="built_in">vehicle_parameter</span>());</span><br></pre></td></tr></table></figure>

<p>每一个车型的factory拥有自己的 controller 和 message manager</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message_manager_ = vehicle_object-&gt;<span class="built_in">CreateMessageManager</span>();</span><br><span class="line">vehicle_controller_ = vehicle_object-&gt;<span class="built_in">CreateVehicleController</span>();</span><br></pre></td></tr></table></figure>

<p>其中controller似乎用于填pb等等事情的</p>
<p>message_manager则用于管理各个信号的decode与encode</p>
<p>以”ch vehicle”为例子，</p>
<p>工厂类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChVehicleFactory</span> : <span class="keyword">public</span> AbstractVehicleFactory</span><br></pre></td></tr></table></figure>

<p>controller类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChController</span> <span class="keyword">final</span> : <span class="keyword">public</span> VehicleController</span><br></pre></td></tr></table></figure>

<p>message manager类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChMessageManager</span> : <span class="keyword">public</span> MessageManager&lt;::apollo::canbus::ChassisDetail&gt;</span><br></pre></td></tr></table></figure>

<p>先看下message manager的构造：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ChMessageManager::<span class="built_in">ChMessageManager</span>() &#123;</span><br><span class="line">  <span class="comment">// Control Messages</span></span><br><span class="line">  <span class="built_in">AddSendProtocolData</span>&lt;Brakecommand111, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddSendProtocolData</span>&lt;Controlcommand115, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddSendProtocolData</span>&lt;Gearcommand114, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddSendProtocolData</span>&lt;Steercommand112, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddSendProtocolData</span>&lt;Throttlecommand110, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddSendProtocolData</span>&lt;Turnsignalcommand113, <span class="literal">true</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Report Messages</span></span><br><span class="line">  <span class="built_in">AddRecvProtocolData</span>&lt;Brakestatus511, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddRecvProtocolData</span>&lt;Ecustatus1515, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddRecvProtocolData</span>&lt;Ecustatus2516, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddRecvProtocolData</span>&lt;Ecustatus3517, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddRecvProtocolData</span>&lt;Gearstatus514, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddRecvProtocolData</span>&lt;Steerstatus512, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddRecvProtocolData</span>&lt;Throttlestatus510, <span class="literal">true</span>&gt;();</span><br><span class="line">  <span class="built_in">AddRecvProtocolData</span>&lt;Turnsignalstatus513, <span class="literal">true</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到message manager中添加了该vehicle的各个收发信号</p>
<p>以<code>Brakestatus511</code>信号为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Brakestatus511</span> : <span class="keyword">public</span> ::apollo::drivers::canbus::ProtocolData&lt;</span><br><span class="line">                           ::apollo::canbus::ChassisDetail&gt;</span><br></pre></td></tr></table></figure>

<p>实现了 parse函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Brakestatus511::Parse</span><span class="params">(<span class="type">const</span> std::<span class="type">uint8_t</span>* bytes, <span class="type">int32_t</span> length,</span></span></span><br><span class="line"><span class="params"><span class="function">                           ChassisDetail* chassis)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  chassis-&gt;<span class="built_in">mutable_ch</span>()-&gt;<span class="built_in">mutable_brake_status__511</span>()-&gt;<span class="built_in">set_brake_pedal_en_sts</span>(</span><br><span class="line">      <span class="built_in">brake_pedal_en_sts</span>(bytes, length));</span><br><span class="line">  chassis-&gt;<span class="built_in">mutable_ch</span>()-&gt;<span class="built_in">mutable_brake_status__511</span>()-&gt;<span class="built_in">set_brake_pedal_sts</span>(</span><br><span class="line">      <span class="built_in">brake_pedal_sts</span>(bytes, length));</span><br><span class="line">  chassis-&gt;<span class="built_in">mutable_ch</span>()-&gt;<span class="built_in">mutable_brake_status__511</span>()-&gt;<span class="built_in">set_brake_err</span>(</span><br><span class="line">      <span class="built_in">brake_err</span>(bytes, length));</span><br><span class="line">  chassis-&gt;<span class="built_in">mutable_ch</span>()-&gt;<span class="built_in">mutable_brake_status__511</span>()-&gt;<span class="built_in">set_emergency_btn_env</span>(</span><br><span class="line">      <span class="built_in">emergency_btn_env</span>(bytes, length));</span><br><span class="line">  chassis-&gt;<span class="built_in">mutable_ch</span>()-&gt;<span class="built_in">mutable_brake_status__511</span>()-&gt;<span class="built_in">set_front_bump_env</span>(</span><br><span class="line">      <span class="built_in">front_bump_env</span>(bytes, length));</span><br><span class="line">  chassis-&gt;<span class="built_in">mutable_ch</span>()-&gt;<span class="built_in">mutable_brake_status__511</span>()-&gt;<span class="built_in">set_back_bump_env</span>(</span><br><span class="line">      <span class="built_in">back_bump_env</span>(bytes, length));</span><br><span class="line">  chassis-&gt;<span class="built_in">mutable_ch</span>()-&gt;<span class="built_in">mutable_brake_status__511</span>()-&gt;<span class="built_in">set_overspd_env</span>(</span><br><span class="line">      <span class="built_in">overspd_env</span>(bytes, length));</span><br><span class="line">  chassis-&gt;<span class="built_in">mutable_check_response</span>()-&gt;<span class="built_in">set_is_esp_online</span>(</span><br><span class="line">      <span class="built_in">brake_pedal_en_sts</span>(bytes, length) == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某个信号的解析如下，这里就是从can frame中按照dbc定义的信号格式解析了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config detail: &#123;&#x27;description&#x27;: &#x27;brake pedal enable bit(Status)&#x27;, &#x27;enum&#x27;: &#123;0:</span></span><br><span class="line"><span class="comment">// &#x27;BRAKE_PEDAL_EN_STS_DISABLE&#x27;, 1: &#x27;BRAKE_PEDAL_EN_STS_ENABLE&#x27;, 2:</span></span><br><span class="line"><span class="comment">// &#x27;BRAKE_PEDAL_EN_STS_TAKEOVER&#x27;&#125;, &#x27;precision&#x27;: 1.0, &#x27;len&#x27;: 8, &#x27;name&#x27;:</span></span><br><span class="line"><span class="comment">// &#x27;brake_pedal_en_sts&#x27;, &#x27;is_signed_var&#x27;: False, &#x27;offset&#x27;: 0.0,</span></span><br><span class="line"><span class="comment">// &#x27;physical_range&#x27;: &#x27;[0|1]&#x27;, &#x27;bit&#x27;: 0, &#x27;type&#x27;: &#x27;enum&#x27;, &#x27;order&#x27;: &#x27;intel&#x27;,</span></span><br><span class="line"><span class="comment">// &#x27;physical_unit&#x27;: &#x27;&#x27;&#125;</span></span><br><span class="line"><span class="function">Brake_status__511::Brake_pedal_en_stsType <span class="title">Brakestatus511::brake_pedal_en_sts</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::<span class="type">uint8_t</span>* bytes, <span class="type">int32_t</span> length)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">Byte <span class="title">t0</span><span class="params">(bytes + <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="type">int32_t</span> x = t0.<span class="built_in">get_byte</span>(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">  Brake_status__511::Brake_pedal_en_stsType ret =</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;Brake_status__511::Brake_pedal_en_stsType&gt;(x);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看controller类的实现，有一个重要函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief calculate and return the chassis.</span></span><br><span class="line"><span class="comment"> * @returns a copy of chassis. Use copy here to avoid multi-thread issues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Chassis <span class="title">chassis</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p>主要做的事情就是从message_manager中获得sensor data，然后填到自己的<code>Chassis chassis_;</code>变量中并返回，后面可以看到sensor data其实是前面parse函数填的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChassisDetail chassis_detail;</span><br><span class="line">message_manager_-&gt;<span class="built_in">GetSensorData</span>(&amp;chassis_detail);</span><br></pre></td></tr></table></figure>



<p>总结一下，单以接收can信号为例，几个关键点</p>
<p>一种车型对应一个factory，该facotry会产生controller和message manager对象</p>
<p>其中 message manager封装了车身信号的decode和encode函数</p>
<p>controller则负责从message manager中获取解析后的数据，并存到<code>Chassis chassis_</code>（这是一个pb 结构体），然后提供API给外部使用</p>
<h3 id="真正的报文接收处理流程"><a href="#真正的报文接收处理流程" class="headerlink" title="真正的报文接收处理流程"></a>真正的报文接收处理流程</h3><p>can报文的接收处理由CanReceiver类管理</p>
<p>CanReceiver由can_client和message manager初始化</p>
<p>并维护一个接收线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SensorType&gt;</span><br><span class="line"><span class="type">void</span> CanReceiver&lt;SensorType&gt;::<span class="built_in">RecvThreadFunc</span>()</span><br></pre></td></tr></table></figure>

<p>在这个线程loop中</p>
<p>使用can_client类的接口接收can frame，这里实际就会调用到socket api</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can_client_-&gt;<span class="built_in">Receive</span>(&amp;buf, &amp;frame_num)</span><br></pre></td></tr></table></figure>

<p>使用message manager 解析刚刚收到的can frame，这里实际就会调用到对应message manager中的信号解析函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt_manager_-&gt;<span class="built_in">Parse</span>(uid, data, len); <span class="comment">//以Brakestatus511信号为例就是上面贴出来的parse函数了</span></span><br></pre></td></tr></table></figure>

<p>在这步parse之后，数据已经填到sensor data了</p>
<h3 id="数据的发布"><a href="#数据的发布" class="headerlink" title="数据的发布"></a>数据的发布</h3><p>CanBusComponent类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CanbusComponent::PublishChassis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Chassis chassis = vehicle_controller_-&gt;<span class="built_in">chassis</span>();</span><br><span class="line">  common::util::<span class="built_in">FillHeader</span>(node_-&gt;<span class="built_in">Name</span>(), &amp;chassis);</span><br><span class="line">  chassis_writer_-&gt;<span class="built_in">Write</span>(chassis);</span><br><span class="line">  ADEBUG &lt;&lt; chassis.<span class="built_in">ShortDebugString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从controller中调用<code>chassis</code>接口，得到chassis数据，然后就使用protobuf writer发布出去了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/19/c-abnormal-exit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WY">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THEWY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/19/c-abnormal-exit/" class="post-title-link" itemprop="url">c++线程异常退出流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-02-19 11:21:44 / Modified: 14:40:32" itemprop="dateCreated datePublished" datetime="2022-02-19T11:21:44+08:00">2022-02-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>问题：</p>
<ol>
<li>当std::thread调用析构时，若thread没有正确退出（没有return），则会产生coredump，为什么？</li>
<li>若在user space捕捉SIGABRT信号，thread异常退出为何还会产生coredump？</li>
</ol>
<p>先来看看coredump的产生</p>
<h1 id="kernel-space"><a href="#kernel-space" class="headerlink" title="kernel space"></a>kernel space</h1><p>内核在处理进程信号时，调用<code>do_signal</code>（arch&#x2F;arm&#x2F;kernel&#x2F;signal.c）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_signal</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">int</span> syscall)</span></span><br></pre></td></tr></table></figure>

<p>接着调用<code>get_signal</code>处理信号，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_signal(&amp;ksig)) &#123;</span><br><span class="line">	handle_signal(&amp;ksig, regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取出信号，若用户有绑定signal handler，则返回non-zero值，调用用户handler，不进行内核默认处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">get_signal</span><span class="params">(<span class="keyword">struct</span> ksignal *ksig)</span> </span><br><span class="line">...</span><br><span class="line">signr = dequeue_signal(current, &amp;current-&gt;blocked, &amp;ksig-&gt;info);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_handler == SIG_IGN) <span class="comment">/* Do nothing.  */</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (ka-&gt;sa.sa_handler != SIG_DFL) &#123;</span><br><span class="line">    <span class="comment">/* Run the handler.  */</span></span><br><span class="line">    ksig-&gt;ka = *ka; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ka-&gt;sa.sa_flags &amp; SA_ONESHOT)</span><br><span class="line">        ka-&gt;sa.sa_handler = SIG_DFL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">/* will return non-zero &quot;signr&quot; value */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若用户没有绑定signal handler，则使用内核默认处理方式</p>
<p>若signal在coredump信号列表定义内，则会产生coredump</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sig_kernel_coredump(signr)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (print_fatal_signals)</span><br><span class="line">        print_fatal_signal(ksig-&gt;info.si_signo);</span><br><span class="line">    proc_coredump_connector(current);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * If it was able to dump core, this kills all</span></span><br><span class="line"><span class="comment">       * other threads in the group and synchronizes with</span></span><br><span class="line"><span class="comment">       * their demise.  If we lost the race with another</span></span><br><span class="line"><span class="comment">       * thread getting here, it set group_exit_code</span></span><br><span class="line"><span class="comment">       * first and our do_group_exit call below will use</span></span><br><span class="line"><span class="comment">       * that value and ignore the one we pass it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    do_coredump(&amp;ksig-&gt;info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意SIGABRT在coredump信号定义内</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_KERNEL_COREDUMP_MASK (\</span></span><br><span class="line"><span class="meta">        rt_sigmask(SIGQUIT)   |  rt_sigmask(SIGILL)    | \</span></span><br><span class="line"><span class="meta">    rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGABRT)   | \</span></span><br><span class="line"><span class="meta">        rt_sigmask(SIGFPE)    |  rt_sigmask(SIGSEGV)   | \</span></span><br><span class="line"><span class="meta">    rt_sigmask(SIGBUS)    |  rt_sigmask(SIGSYS)    | \</span></span><br><span class="line"><span class="meta">        rt_sigmask(SIGXCPU)   |  rt_sigmask(SIGXFSZ)   | \</span></span><br><span class="line"><span class="meta">    SIGEMT_MASK                    )</span></span><br></pre></td></tr></table></figure>

<p>显然，线程退出时，进程收到了满足coredump的信号，才会产生coredump</p>
<p>接着看user space的实现，线程析构时，发出了什么信号</p>
<h1 id="user-space"><a href="#user-space" class="headerlink" title="user space"></a>user space</h1><p>局部对象实例在离开作用域时会被调用析构函数，std线程的析构函数如下：</p>
<img src="/2022/02/19/c-abnormal-exit/thread.png" class="" title="thread">

<p>若线程因一些原因如busy waiting而没有退出，其joinable会为true，则析构会调用<code>terminate</code></p>
<img src="/2022/02/19/c-abnormal-exit/terminate.png" class="" title="terminate">

<p><code>terminate</code>默认会调用<code>abort</code></p>
<p>看下glibc中abort的实现：</p>
<p><a target="_blank" rel="noopener" href="https://code.woboq.org/userspace/glibc/stdlib/abort.c.html">https://code.woboq.org/userspace/glibc/stdlib/abort.c.html</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send signal which possibly calls a user handler.  */</span></span><br><span class="line">  <span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This stage is special: we must allow repeated calls of</span></span><br><span class="line"><span class="comment">         `abort&#x27; when a user defined handler for SIGABRT is installed.</span></span><br><span class="line"><span class="comment">         This is risky since the `raise&#x27; implementation might also</span></span><br><span class="line"><span class="comment">         fail but I don&#x27;t see another possibility.  */</span></span><br><span class="line">      <span class="type">int</span> save_stage = stage;</span><br><span class="line">      stage = <span class="number">0</span>;</span><br><span class="line">      __libc_lock_unlock_recursive (lock);</span><br><span class="line">      raise (SIGABRT);</span><br><span class="line">      __libc_lock_lock_recursive (lock);</span><br><span class="line">      stage = save_stage + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* There was a handler installed.  Now remove it.  */</span></span><br><span class="line">  <span class="keyword">if</span> (stage == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++stage;</span><br><span class="line">      <span class="built_in">memset</span> (&amp;act, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> sigaction));</span><br><span class="line">      act.sa_handler = SIG_DFL;</span><br><span class="line">      __sigfillset (&amp;act.sa_mask);</span><br><span class="line">      act.sa_flags = <span class="number">0</span>;</span><br><span class="line">      __sigaction (SIGABRT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* Try again.  */</span></span><br><span class="line">  <span class="keyword">if</span> (stage == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ++stage;</span><br><span class="line">      raise (SIGABRT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，abort会先发送一次<code>SIGABRT</code></p>
<p>然后清掉用户捕捉信号的handler</p>
<p>再发送一次<code>SIGABRT</code></p>
<h1 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h1><p>线程析构发生terminate时，会调用abort先产生一次SIGABRT</p>
<p>内核发现用户若有注册handler，则调用用户handler，此时不产生coredump</p>
<p>之后，abort函数清除掉用户的handler，再发一次ABRT信号</p>
<p>此时内核发现没有用户handler，走默认处理函数，ARBT信号产生coredump  </p>
<p><strong>所以线程异常退出产生coredump的原因是发出了SIGABRT信号</strong></p>
<p><strong>而即使在user space设置了SIGABRT的捕捉信号，由于abort函数的机制，仍然会产生coredump</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/19/rust-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WY">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THEWY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/19/rust-study/" class="post-title-link" itemprop="url">rust study</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-02-19 10:49:17 / Modified: 10:53:27" itemprop="dateCreated datePublished" datetime="2022-02-19T10:49:17+08:00">2022-02-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rust/" itemprop="url" rel="index"><span itemprop="name">rust</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h1><p>Rust是由Mozilla主导开发的通用、编译型编程语言。设计准则为“安全、并发、实用”，支持函数式、并发式、过程式以及面向对象的编程风格。</p>
<p>特性：</p>
<ul>
<li>强类型静态语言</li>
</ul>
<p>​    编译时就知道变量类型的是静态，运行时才知道变量类型的是动态（解释性语言如python）</p>
<p>​    不允许隐式转换的是强类型，允许隐式转换的是弱类型</p>
<p><img src="https://pic1.zhimg.com/80/b0aeb7ffd1667b9162e5329154d43777_720w.jpg?source=1940ef5c" alt="img"></p>
<ul>
<li><p>函数式编程</p>
<p>函数式编程中的函数不是指计算机中的函数，而是数学中的函数，即自变量的映射f(x)。一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都不变，所以纯函数式编程中，变量是代数中的变量，即一个值的名称，变量的值是不可变的，比如<code>x = x + 1</code>在数学代数里，这个等式为假，由于变量值是不可变的，对于值的操作并不是修改原来的值，而是修改新产生的值，原来的值保持不变</p>
</li>
<li><p>没有GC，不用care alloc和free，以ownership和lifetime替代</p>
<p>GC: garbage collection，显式申请内存，但不需要主动释放，GC在程序跑的时候会时不时的去找没有在用的memory并释放它 (Java)</p>
<p>alloc&#x2F;free: alloc和free要配对，显式申请的内存要主动的释放 (C)</p>
<p>rust不需要以上两种，利用ownership和lifetime的特性，编译时就会检查很多要求，能编译过就没有内存问题（不存在空指针，内存泄露）</p>
</li>
<li><p>零开销抽象zero cost abstraction 如C++</p>
<p>提供面向对象，高级抽象，多态 （trait，impl，generic…. 类比C++ class，template，interface）</p>
</li>
<li><p>强大的测试系统</p>
<p>[test] ，单元测试的极致，在开发过程中可以测试任何一段code</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网安装方法：</p>
<p>使用rustup，The Rust toolchain installer</p>
<p>获取rustup并运行：curl –proto ‘&#x3D;https’ –tlsv1.2 -sSf <a target="_blank" rel="noopener" href="https://sh.rustup.rs/">https://sh.rustup.rs</a> | sh</p>
<p>install path</p>
<p>rustc –version 检查安装成功</p>
<p>编译器为rustc，使用rustup可以配置toolchain等</p>
<p>编译单个文件为 rustc xxx.rs</p>
<p>多个文件使用cargo包管理工具</p>
<p>cargo用以上方法伴随着会安装</p>
<p>创建项目 cargo new xxx</p>
<p>里面会自动生成 配置文件和 主函数main.rs</p>
<p>Cargo.toml 是配置文件，类似于Makefile</p>
<blockquote>
<p>  [package]<br>  name &#x3D; “dbc”<br>  version &#x3D; “0.1.0”<br>  authors &#x3D; [“xxx”]<br>  edition &#x3D; “2018”</p>
<p>  [dependencies]<br>  can-dbc &#x3D; { path &#x3D; “.&#x2F;can-dbc” }<br>  clap &#x3D; “2.33”<br>  derive_more &#x3D; “0.99”<br>  socketcan &#x3D; “1.7”</p>
<p>[dependencies.nom]<br>  version &#x3D; “4.2”<br>  features &#x3D; [“verbose-errors”]</p>
</blockquote>
<p>其中[dependecies] 定义了 依赖的库</p>
<p>执行cargo build即可编译出可执行文件或lib</p>
<p>vscode安装rust插件：ctrl+shitft+x </p>
<ul>
<li>输入 Rust，安装</li>
<li>输入 rust-analyzer，安装</li>
</ul>
<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>followed by rust-by-example: <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rust-by-example/index.html">https://doc.rust-lang.org/rust-by-example/index.html</a></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>基本：</p>
<ul>
<li>signed integers: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code> and <code>isize</code> (pointer size)</li>
<li>unsigned integers: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> and <code>usize</code> (pointer size)</li>
<li>floating point: <code>f32</code>, <code>f64</code></li>
<li><code>char</code> Unicode scalar values like <code>&#39;a&#39;</code>, <code>&#39;α&#39;</code> and <code>&#39;∞&#39;</code> (4 bytes each)</li>
<li><code>bool</code> either <code>true</code> or <code>false</code></li>
<li>and the unit type <code>()</code>, whose only possible value is an empty tuple: <code>()</code></li>
</ul>
<p>复合：</p>
<ul>
<li>arrays like <code>[1, 2, 3]</code></li>
<li><strong>tuples</strong> like <code>(1, true)</code></li>
</ul>
<p>自定义：</p>
<ul>
<li><p><code>struct</code>: define a structure</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// A unit struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unit</span>; <span class="comment">//useful for generics(template)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// A tuple struct</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>(<span class="type">i32</span>, <span class="type">f32</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// A struct with two fields</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f32</span>,</span><br><span class="line">    y: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>enum</code>: define an enumeration</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WebEvent</span> &#123;</span><br><span class="line">    <span class="comment">// An `enum` may either be `unit-like`,</span></span><br><span class="line">    PageLoad,</span><br><span class="line">    PageUnload,</span><br><span class="line">    <span class="comment">// like tuple structs,</span></span><br><span class="line">    <span class="title function_ invoke__">KeyPress</span>(<span class="type">char</span>),</span><br><span class="line">    <span class="title function_ invoke__">Paste</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="comment">// or c-like structures.</span></span><br><span class="line">    Click &#123; x: <span class="type">i64</span>, y: <span class="type">i64</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>using the <code>let</code> binding:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>: <span class="type">bool</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pair</span> = (<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">ar</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f32</span>,</span><br><span class="line">    y: <span class="type">f32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">point</span>: Point = Point &#123; x: <span class="number">10.3</span>, y: <span class="number">0.4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>默认的赋值操作都是immutable（不可修改）的，即赋值后，值不能再改了</p>
<p>使用<code>mut</code>关键字可将 不可修改的 变成 可修改的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_immutable_binding</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutable_binding</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Before mutation: &#123;&#125;&quot;</span>, mutable_binding);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ok</span></span><br><span class="line">mutable_binding += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;After mutation: &#123;&#125;&quot;</span>, mutable_binding);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error!</span></span><br><span class="line">_immutable_binding += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>rust程序由表达式组成，以<code>;</code>结尾</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// variable binding</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expression;</span></span><br><span class="line">    x;</span><br><span class="line">    x + <span class="number">1</span>;</span><br><span class="line">    <span class="number">15</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中括号括起来的块(block)也是表达式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x_squared</span> = x * x;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x_cube</span> = x_squared * x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This expression will be assigned to `y`</span></span><br><span class="line">    x_cube + x_squared + x</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>block里的最后一句就是输出的表达式，但如果加了分号<code>;</code>，那么输出的结果就是<code>()</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = &#123;</span><br><span class="line">    <span class="comment">// The semicolon suppresses this expression and `()` is assigned to `z`</span></span><br><span class="line">    <span class="number">2</span> * x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><ul>
<li><p>if&#x2F;else</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> <span class="variable">n</span> = <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//if 后面接 bool condition</span></span><br><span class="line">   <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; is negative&quot;</span>, n);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; is positive&quot;</span>, n);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; is zero&quot;</span>, n);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>loop&#x2F;while</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">   	<span class="comment">//do something</span></span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//loop with conditon</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">101</span> &#123;</span><br><span class="line">	<span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for and range</p>
<p>使用<code>for in</code>接iterator</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> <span class="variable">names</span> = <span class="built_in">vec!</span>[<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Frank&quot;</span>, <span class="string">&quot;Ferris&quot;</span>];</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">for</span> <span class="variable">name</span> <span class="keyword">in</span> names.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;&#125;&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>match</strong></p>
<p>类似于C语言的<code>switch</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> number &#123;</span><br><span class="line">    <span class="comment">// Match a single value</span></span><br><span class="line">    <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;One!&quot;</span>),</span><br><span class="line">    <span class="comment">// Match several values</span></span><br><span class="line">    <span class="number">2</span> | <span class="number">3</span> | <span class="number">5</span> | <span class="number">7</span> | <span class="number">11</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;This is a prime&quot;</span>),</span><br><span class="line">    <span class="comment">// Match an inclusive range</span></span><br><span class="line">    <span class="number">13</span>..=<span class="number">19</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;A teen&quot;</span>),</span><br><span class="line">    <span class="comment">// Handle the rest of cases</span></span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Ain&#x27;t special&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>match可以做<strong>destructing</strong>，很有用哦～</p>
<ul>
<li><p>Destructuring Tuples</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">triple</span> = (<span class="number">0</span>, -<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match can be used to destructure a tuple</span></span><br><span class="line"><span class="keyword">match</span> triple &#123;</span><br><span class="line">    <span class="comment">// Destructure the second and third elements</span></span><br><span class="line">    (<span class="number">0</span>, y, z) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;First is `0`, `y` is &#123;:?&#125;, and `z` is &#123;:?&#125;&quot;</span>, y, z),</span><br><span class="line">    (<span class="number">1</span>, ..)  =&gt; <span class="built_in">println!</span>(<span class="string">&quot;First is `1` and the rest doesn&#x27;t matter&quot;</span>),</span><br><span class="line">    <span class="comment">// `..` can be the used ignore the rest of the tuple</span></span><br><span class="line">    _      =&gt; <span class="built_in">println!</span>(<span class="string">&quot;It doesn&#x27;t matter what they are&quot;</span>),</span><br><span class="line">    <span class="comment">// `_` means don&#x27;t bind the value to a variable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Destructuring Enums</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    <span class="comment">// These 3 are specified solely by their name.</span></span><br><span class="line">    Red,</span><br><span class="line">    Blue,</span><br><span class="line">    Green,</span><br><span class="line">    <span class="comment">// These likewise tie `u32` tuples to different names: color models.</span></span><br><span class="line">    <span class="title function_ invoke__">RGB</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">    <span class="title function_ invoke__">HSV</span>(<span class="type">u32</span>, <span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">color</span> = Color::<span class="title function_ invoke__">RGB</span>(<span class="number">122</span>, <span class="number">17</span>, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An `enum` can be destructured using a `match`.</span></span><br><span class="line">    <span class="keyword">match</span> color &#123;</span><br><span class="line">        Color::Red   =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The color is Red!&quot;</span>),</span><br><span class="line">        Color::Blue  =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The color is Blue!&quot;</span>),</span><br><span class="line">        Color::Green =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The color is Green!&quot;</span>),</span><br><span class="line">        Color::<span class="title function_ invoke__">RGB</span>(r, g, b) =&gt;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Red: &#123;&#125;, green: &#123;&#125;, and blue: &#123;&#125;!&quot;</span>, r, g, b),</span><br><span class="line">        Color::<span class="title function_ invoke__">HSV</span>(h, s, v) =&gt;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hue: &#123;&#125;, saturation: &#123;&#125;, value: &#123;&#125;!&quot;</span>, h, s, v),</span><br><span class="line">        Color::<span class="title function_ invoke__">HSL</span>(h, s, l) =&gt;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hue: &#123;&#125;, saturation: &#123;&#125;, lightness: &#123;&#125;!&quot;</span>, h, s, l),</span><br><span class="line">        <span class="comment">// Don&#x27;t need another arm because all variants have been examined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Destructuring Structures</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    x: (<span class="type">u32</span>, <span class="type">u32</span>),</span><br><span class="line">    y: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">foo</span> = Foo &#123; x: (<span class="number">1</span>, <span class="number">2</span>), y: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> foo &#123;</span><br><span class="line">    Foo &#123; x: (<span class="number">1</span>, b), y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;First of x is 1, b = &#123;&#125;,  y = &#123;&#125; &quot;</span>, b, y),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// you can destructure structs and rename the variables,</span></span><br><span class="line">    <span class="comment">// the order is not important</span></span><br><span class="line">    Foo &#123; y: <span class="number">2</span>, x: i &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;y is 2, i = &#123;:?&#125;&quot;</span>, i),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// and you can also ignore some variables:</span></span><br><span class="line">    Foo &#123; y, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;, we don&#x27;t care about x&quot;</span>, y),</span><br><span class="line">    <span class="comment">// this will give an error: pattern does not mention field `x`</span></span><br><span class="line">    <span class="comment">//Foo &#123; y &#125; =&gt; println!(&quot;y = &#123;&#125;&quot;, y),</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>using the <code>fn</code> keyword，参数即跟类型声明一样，如果有返回值，则使用<code>-&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function that returns a boolean value</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_divisible_by</span>(lhs: <span class="type">u32</span>, rhs: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// Corner case, early return</span></span><br><span class="line">    <span class="keyword">if</span> rhs == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is an expression, the `return` keyword is not necessary here</span></span><br><span class="line">    lhs % rhs == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust注重检查返回值，在C中，通常我们使用if else等判断 返回的ret，C++中可能会实现exception来catch error，而rust的函数则比较喜欢返回 <code>Result</code>这个枚举</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中T，E 可以是你指定的任意类型，然后通常会用match去处理返回的Result</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面说过，match有<strong>destruted</strong>的功能，这里的返回值Result也是一个enum，其中的T和E，可以被destruted出来直接使用，很neat</p>
<p>类似的还有<code>Option&lt;T&gt;</code></p>
<p>The <code>Option&lt;T&gt;</code> enum has two variants:</p>
<ul>
<li><code>None</code>, to indicate failure or lack of value, and</li>
<li><code>Some(value)</code>, a tuple struct that wraps a <code>value</code> with type <code>T</code>.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An integer division that doesn&#x27;t `panic!`</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">checked_division</span>(dividend: <span class="type">i32</span>, divisor: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> divisor == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Failure is represented as the `None` variant</span></span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Result is wrapped in a `Some` variant</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(dividend / divisor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function handles a division that may not succeed</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">try_division</span>(dividend: <span class="type">i32</span>, divisor: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// `Option` values can be pattern matched, just like other enums</span></span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">checked_division</span>(dividend, divisor) &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; / &#123;&#125; failed!&quot;</span>, dividend, divisor),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(quotient) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; / &#123;&#125; = &#123;&#125;&quot;</span>, dividend, divisor, quotient)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">try_division</span>(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="title function_ invoke__">try_division</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binding `None` to a variable needs to be type annotated</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_equivalent_none</span> = None::&lt;<span class="type">i32</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">optional_float</span> = <span class="title function_ invoke__">Some</span>(<span class="number">0f32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unwrapping a `Some` variant will extract the value wrapped.</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; unwraps to &#123;:?&#125;&quot;</span>, optional_float, optional_float.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unwrapping a `None` variant will `panic!`</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; unwraps to &#123;:?&#125;&quot;</span>, none, none.<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个<code>unwrap()</code>用法，也很常用</p>
<h2 id="Ownership-and-moves"><a href="#Ownership-and-moves" class="headerlink" title="Ownership and moves"></a>Ownership and moves</h2><p>ownership的规则如下：</p>
<ul>
<li>Each value in Rust has a variable that’s called its <em>owner</em>.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s is valid from this point forward</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do stuff with s</span></span><br><span class="line">&#125;                                  <span class="comment">// this scope is now over, and s is no longer valid</span></span><br></pre></td></tr></table></figure>

<p>moves即为ownership的转移，通常发生在赋值或传参时，如</p>
<p><code>let x = y</code>表示将y 给了 x，ownership转移给了x，转移后，y就不能继续使用了</p>
<p>对于基本类型，赋值会发生copy，其它类型才会发生move</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x; <span class="comment">//copy, x,y都可以用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = String::<span class="title function_ invoke__">new</span>(); <span class="comment">//在heap上创建了内存，a指向它</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a; <span class="comment">//move, a无法acess前面创建的内存了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s&#x27;s value moves into the function...</span></span><br><span class="line">                                    <span class="comment">// ... and so is no longer valid here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x comes into scope</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x would move into the function,</span></span><br><span class="line">                                    <span class="comment">// but i32 is Copy, so it’s okay to still</span></span><br><span class="line">                                    <span class="comment">// use x afterward</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// Here, x goes out of scope, then s. But because s&#x27;s value was moved, nothing</span></span><br><span class="line">  <span class="comment">// special happens.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string comes into scope</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// Here, some_string goes out of scope and `drop` is called. The backing</span></span><br><span class="line">  <span class="comment">// memory is freed.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer comes into scope</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// Here, some_integer goes out of scope. Nothing special happens.</span></span><br></pre></td></tr></table></figure>



<h2 id="Borrowing"><a href="#Borrowing" class="headerlink" title="Borrowing"></a>Borrowing</h2><p>move操作可发生在传参时，如</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">func</span>(s: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="comment">///use s do something</span></span><br><span class="line">&#125;<span class="comment">// s outof scope, destroy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">func</span>(s); <span class="comment">// s move到了func里面</span></span><br><span class="line">    <span class="comment">//无法继续使用s了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以很多时候我们要用一个值但又不想被拿走ownership，会使用borrorw操作，传值时传reference(&amp;T)而不是 value(T)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">func</span>(s: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    <span class="comment">///use s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">func</span>(&amp;s);</span><br><span class="line">    <span class="comment">//s可以继续使用，内存没有被释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>使用<code>impl</code>关键字来定一个object的方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation block, all `Point` methods go in here</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">// This is a static method</span></span><br><span class="line">    <span class="comment">// Static methods don&#x27;t need to be called by an instance</span></span><br><span class="line">    <span class="comment">// These methods are generally used as constructors</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">origin</span>() <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123; x: <span class="number">0.0</span>, y: <span class="number">0.0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Another static method, taking two arguments:</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123; x: x, y: y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p1</span> = Point::<span class="title function_ invoke__">origin</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">p2</span> = Point::<span class="title function_ invoke__">new</span>(<span class="number">3.0</span>, <span class="number">4.0</span>);</span><br></pre></td></tr></table></figure>

<p>另一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    p1: Point,</span><br><span class="line">    p2: Point,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// This is an instance method</span></span><br><span class="line">    <span class="comment">// `&amp;self` is sugar for `self: &amp;Self`, where `Self` is the type of the</span></span><br><span class="line">    <span class="comment">// caller object. In this case `Self` = `Rectangle`</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="comment">// `self` gives access to the struct fields via the dot operator</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x1, y: y1 &#125; = <span class="keyword">self</span>.p1;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x2, y: y2 &#125; = <span class="keyword">self</span>.p2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `abs` is a `f64` method that returns the absolute value of the</span></span><br><span class="line">        <span class="comment">// caller</span></span><br><span class="line">        ((x1 - x2) * (y1 - y2)).<span class="title function_ invoke__">abs</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">perimeter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x1, y: y1 &#125; = <span class="keyword">self</span>.p1;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x2, y: y2 &#125; = <span class="keyword">self</span>.p2;</span><br><span class="line"></span><br><span class="line">        <span class="number">2.0</span> * ((x1 - x2).<span class="title function_ invoke__">abs</span>() + (y1 - y2).<span class="title function_ invoke__">abs</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">rectangle</span> = Rectangle &#123;</span><br><span class="line">    <span class="comment">// Static methods are called using double colons</span></span><br><span class="line">    p1: Point::<span class="title function_ invoke__">origin</span>(),</span><br><span class="line">    p2: Point::<span class="title function_ invoke__">new</span>(<span class="number">3.0</span>, <span class="number">4.0</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instance methods are called using the dot operator</span></span><br><span class="line"><span class="comment">// Note that the first argument `&amp;self` is implicitly passed, i.e.</span></span><br><span class="line"><span class="comment">// `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Rectangle perimeter: &#123;&#125;&quot;</span>, rectangle.<span class="title function_ invoke__">perimeter</span>());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Rectangle area: &#123;&#125;&quot;</span>, rectangle.<span class="title function_ invoke__">area</span>());</span><br></pre></td></tr></table></figure>

<p>rust的struct可以类比为C++的类，但很大的不同是：</p>
<p>C++的数据成员和成员方法都定义在类里面，而rust是分开的，struct只定义数据成员，它的方法定义在impl block body里面</p>
<p>可以理解为struct + impl methods实现了 一个 拥有特定成员和相应方法的object，就很像是C++的class了</p>
<h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><p>A <code>trait</code> is <strong>a collection of methods</strong> defined for an unknown type: <code>Self</code></p>
<p>Traits can be implemented <strong>for any data type</strong>.</p>
<p>类比于C++的interface</p>
<p>实现一个trait:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给NewsArticle实现一个trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给Tweet实现一个trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">tweet</span> = Tweet &#123; <span class="comment">/*xxxx*/</span> &#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;1 new tweet: &#123;&#125;&quot;</span>, tweet.<span class="title function_ invoke__">summarize</span>());</span><br></pre></td></tr></table></figure>

<p>trait可以定义default的函数，让实现它的type可以调用通用默认的函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">article</span> = NewsArticle &#123;</span><br><span class="line">        headline: String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>),</span><br><span class="line">        location: String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">        author: String::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">        content: String::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;The Pittsburgh Penguins once again are the best \</span></span><br><span class="line"><span class="string">             hockey team in the NHL.&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;New article available! &#123;&#125;&quot;</span>, article.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果输出为 New article available! (Read more...)</span></span><br></pre></td></tr></table></figure>

<p>和methods的区别：</p>
<p>trait是定义了一组方法的一种type</p>
<p>然后被<code>impl</code>给其它data type，其它data type可以使用trait里的函数或overwrite成自己的定义的同名函数</p>
<p>而methods是实现为某个object的方法，而不是common的interface在多个type去共用的</p>
<h4 id="Trait-实现rust的多态"><a href="#Trait-实现rust的多态" class="headerlink" title="Trait 实现rust的多态"></a>Trait 实现rust的多态</h4><p>trait 的impl –&gt; 有继承的味道</p>
<p>一般面向对象语言如C++，通过继承来实现多态</p>
<p>举个栗子，一个GUI库，里面有多个component如按钮，图标，多选框，都有自己的draw函数来绘制自己的组件</p>
<p>所以一般会实现一个 component的父类，2然后 各个子组件再继承同个父类并实现自己的draw，然后由父类引用子类来调用它自己的draw</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Component *com;</span><br><span class="line">button but;</span><br><span class="line">iamge img;</span><br><span class="line"></span><br><span class="line">com = &amp;but;</span><br><span class="line">com-&gt;<span class="built_in">draw</span>();<span class="comment">//画按钮</span></span><br><span class="line"></span><br><span class="line">com = &amp;img;</span><br><span class="line">com-&gt;<span class="built_in">draw</span>();<span class="comment">//画图形</span></span><br></pre></td></tr></table></figure>

<p>多态可以做到，运行时，才确定com的引用是哪个，即运行时才会确定draw方法具体调用的哪个（运行时多态），这样可以实现出比较清晰的业务逻辑 </p>
<p>rust的多态如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//button</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> label: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//button自己的draw逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//image</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">image</span> &#123;</span><br><span class="line">    <span class="comment">//...image 自己的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//image自己的draw逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw这个trait作为参数传入</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_something</span>(com: &amp;<span class="keyword">dyn</span> Draw) &#123;</span><br><span class="line">    com.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="static-dispatch-vs-dynamic-dispatch"><a href="#static-dispatch-vs-dynamic-dispatch" class="headerlink" title="static dispatch vs dynamic dispatch"></a>static dispatch vs dynamic dispatch</h3><p>static dispath就是编译时就确定具体类型的，一般是模板</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define an example struct, make it printable</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// an example trait</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baz</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement the trait for Foo</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Bar</span> <span class="keyword">for</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baz</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a generic function that takes any T that implements trait Bar.</span></span><br><span class="line"><span class="comment">// It must resolve to a specific concrete T at compile time.</span></span><br><span class="line"><span class="comment">// The compiler creates a different version of this function</span></span><br><span class="line"><span class="comment">// for each concrete type used to call it so &amp;T here is NOT</span></span><br><span class="line"><span class="comment">// a trait object (as T will represent a known, sized type</span></span><br><span class="line"><span class="comment">// after compilation)</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">static_dispatch</span>&lt;T&gt;(t: &amp;T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Bar,</span><br><span class="line">&#123;</span><br><span class="line">    t.<span class="title function_ invoke__">baz</span>(); <span class="comment">// we can do this because t implements Bar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">func_bar</span>(f: &amp;Foo) &#123;</span><br><span class="line">    f.<span class="title function_ invoke__">baz</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foo</span> = Foo;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">static_dispatch</span>(&amp;foo);<span class="comment">//如果这里传的不是impl了Bar trait的，无法编译</span></span><br><span class="line">    <span class="comment">//如果有其它impl了Bar的类型，编译器都会生成一个对应的函数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dynamic dispatch就是run time时才确定具体类型的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function takes a pointer to a something that implements trait Bar</span></span><br><span class="line"><span class="comment">// (it&#x27;ll know what it is only at runtime). &amp;dyn Bar is a trait object.</span></span><br><span class="line"><span class="comment">// There&#x27;s only one version of this function at runtime, so this</span></span><br><span class="line"><span class="comment">// reduces the size of the compiled program if the function</span></span><br><span class="line"><span class="comment">// is called with several different types vs using static_dispatch.</span></span><br><span class="line"><span class="comment">// However performance is slightly lower, as the &amp;dyn Bar that</span></span><br><span class="line"><span class="comment">// dynamic_dispatch receives is a pointer to the object +</span></span><br><span class="line"><span class="comment">// a vtable with all the Bar methods that the object implements.</span></span><br><span class="line"><span class="comment">// Calling baz() on t means having to look it up in this vtable.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dynamic_dispatch</span>(t: &amp;<span class="keyword">dyn</span> Bar) &#123;</span><br><span class="line">    <span class="comment">// ----------------^</span></span><br><span class="line">    <span class="comment">// this is the trait object! It would also work with Box&lt;dyn Bar&gt; or</span></span><br><span class="line">    <span class="comment">// Rc&lt;dyn Bar&gt; or Arc&lt;dyn Bar&gt;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    t.<span class="title function_ invoke__">baz</span>(); <span class="comment">// we can do this because t implements Bar</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foo</span> = Foo;</span><br><span class="line">    <span class="title function_ invoke__">dynamic_dispatch</span>(&amp;foo);<span class="comment">//即使传其它impl Bar的类型进来，也只有一个fn会被编译器生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管是static还是dynamic，你都可以做到传不同类型的输入，然后得到各自类型实现的输出</p>
<p>这里的区别在于最后生成的code size和speed，static因为每个模板都会被编译器输出，所以会有很多类似的copies，code size比dynamic大，而dynamic为了实现它的dynamic，它多了指针和vtable，性能会低一丢丢</p>
<p>以上是实现了某trait的struct作为参数传入funtion，如果我们想返回一个实现了某trait的struct呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sheep</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cow</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// Instance method signature</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement the `Animal` trait for `Sheep`.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;baaaaah!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement the `Animal` trait for `Cow`.</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Cow</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;moooooo!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns some struct that implements Animal, but we don&#x27;t know which one at compile time.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">random_animal</span>(random_number: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Animal&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> random_number &lt; <span class="number">0.5</span> &#123;</span><br><span class="line">        Box::<span class="title function_ invoke__">new</span>(Sheep &#123;&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Box::<span class="title function_ invoke__">new</span>(Cow &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//box的size是确定的两个usize，指向内存的pointer和对应的length</span></span><br><span class="line"><span class="comment">//编译时即知道，你要返回的是一个 pointer和len的组合，是一个长度为两个usize的东西</span></span><br><span class="line"><span class="comment">//如果直接 -&gt; Animal</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> fn random_animal(random_number: f64) -&gt; Animal &#123;</span></span><br><span class="line"><span class="comment">   |                                         ^^^^^^ doesn&#x27;t have a size known at compile-time</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<p>这部分还有很多设计方面的思想和细节我还没体会理解到，以后再讲～</p>
<h2 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h2><p>Closures are functions that can capture the enclosing environment.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|val| val + x</span><br></pre></td></tr></table></figure>

<ul>
<li>using <code>||</code> instead of <code>()</code> around input variables.</li>
<li>optional body delimination (<code>&#123;&#125;</code>) for a single expression (mandatory otherwise).</li>
<li>the ability to capture the outer environment variables.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Increment via closures and functions.</span></span><br><span class="line">    <span class="keyword">fn</span>  <span class="title function_">function</span>            (i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; i + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Closures are anonymous, here we are binding them to references</span></span><br><span class="line">    <span class="comment">// Annotation is identical to function annotation but is optional</span></span><br><span class="line">    <span class="comment">// as are the `&#123;&#125;` wrapping the body. These nameless functions</span></span><br><span class="line">    <span class="comment">// are assigned to appropriately named variables.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_annotated</span> = |i: <span class="type">i32</span>| <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; i + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">closure_inferred</span>  = |i     |          i + <span class="number">1</span>  ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Call the function and closures.</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;function: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">function</span>(i));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;closure_annotated: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">closure_annotated</span>(i));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;closure_inferred: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">closure_inferred</span>(i));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A closure taking no arguments which returns an `i32`.</span></span><br><span class="line">    <span class="comment">// The return type is inferred.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = || <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;closure returning one: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">one</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>闭包就是在一个函数内创建立即调用的另一个函数。</li>
<li>闭包是一个匿名函数。也就是没有函数名称。</li>
<li>闭包虽然没有函数名，但可以把整个闭包赋值一个变量，通过调用该变量来完成闭包的调用。从某些方面说，这个变量就是函数名的作用。</li>
<li>闭包不用声明返回值，但它却可以有返回值。并且使用最后一条语句的执行结果作为返回值。闭包的返回值可以赋值给变量。</li>
<li>闭包有时候有些地方又称之为 <strong>内联函数</strong>。这种特性使得闭包可以访问外层函数里的变量。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">function_name</span>(parameters) <span class="punctuation">-&gt;</span> return_type &#123;</span><br><span class="line">   <span class="comment">// 函数的具体逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包是一个没有函数名的内联函数</span></span><br><span class="line">|parameter| &#123;</span><br><span class="line">   <span class="comment">// 闭包的具体逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//闭包就是普通函数去掉 fn 关键字，去掉函数名，去掉返回值声明，并把一对小括号改成一对 竖线 ||</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包的参数是可选的，如果一个闭包没有参数，那么它的定义语法格式如下</span></span><br><span class="line">||&#123;</span><br><span class="line">   <span class="comment">// 闭包的具体逻辑  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包虽然没有名称，但我们可以将闭包赋值给一个变量，然后就可以通过调用这个变量来完成闭包的调用</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">closure_function</span> = |parameter| &#123;</span><br><span class="line">   <span class="comment">// 闭包的具体逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">closure_function</span>(parameter);    <span class="comment">//invoking</span></span><br></pre></td></tr></table></figure>

<p>why use closure ?</p>
<ol>
<li>减少重复代码</li>
<li>代码会变得简单易读（   熟练之后 :)   ）</li>
<li>很灵活，在迭代器里很好用</li>
<li>……</li>
</ol>
<h2 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h2><p>Tests are Rust functions that verify that the non-test code is functioning in the expected manner</p>
<p>To change a function into a test function, add <code>#[test]</code> on the line before <code>fn</code></p>
<p>当执行<code>cargo test</code>时，rust 会编译一个可执行bin跑声明了test的函数，然后就可以看测试结果</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当运行<code>cargo test</code>时，可以清楚知道运行结果，很方便做模块的单元测试</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cargo test</span><br><span class="line">   Compiling adder v0.<span class="number">1.0</span> (file:<span class="comment">///projects/adder)</span></span><br><span class="line">    Finished test [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.57</span>s</span><br><span class="line">     Running target/debug/deps/adder-<span class="number">92948</span>b65e88960b4</span><br><span class="line"></span><br><span class="line">running <span class="number">1</span> test</span><br><span class="line">test tests::it_works ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">1</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running <span class="number">0</span> tests</span><br><span class="line"></span><br><span class="line">test result: ok. <span class="number">0</span> passed; <span class="number">0</span> failed; <span class="number">0</span> ignored; <span class="number">0</span> measured; <span class="number">0</span> filtered out</span><br></pre></td></tr></table></figure>



<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>TODO</p>
<p>实际上async函数是由编辑器生成的future，await也是由编译器生成代码调用future的poll方法</p>
<p>Every <code>await</code> point is like a <code>yield</code> point.</p>
<p>Instead of <code>yielding</code> a value we pass in, we yield the result of calling <code>poll</code> on the next <code>Future</code> we’re awaiting.</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/learning-rust-in-2020.md">https://github.com/pretzelhammer/rust-blog/blob/master/posts/learning-rust-in-2020.md</a></p>
<p><a target="_blank" rel="noopener" href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">https://fasterthanli.me/articles/a-half-hour-to-learn-rust</a>  半小时过一遍大部分语法</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rust-lang/rustlings">https://github.com/rust-lang/rustlings</a> 一组涵盖大部分语法和特性的半成品程序，让你去补充，使之编译test过，通过提示和编译器输出的error来做，做完会有大体的了解和熟悉</p>
<p><a target="_blank" rel="noopener" href="https://exercism.io/tracks/rust">https://exercism.io/tracks/rust</a> rust从易到难的习题，刷题的味道</p>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/">https://doc.rust-lang.org/std/</a>  官方STD库，使用std提供的内容时，来这里查它的定义、方法、trait等</p>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/rust-by-example/">https://doc.rust-lang.org/rust-by-example/</a>  官方文档，绝大部分语法的example在这里面，不记得某个基础操作时来这里迅速找例子</p>
<p><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/title-page.html">https://doc.rust-lang.org/stable/book/title-page.html</a>  The Book， 官方圣经级别，不好读</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WY">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="THEWY">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/12/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-02-12 10:47:47 / Modified: 12:03:45" itemprop="dateCreated datePublished" datetime="2022-02-12T10:47:47+08:00">2022-02-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/thoughts/" itemprop="url" rel="index"><span itemprop="name">thoughts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>学而不思则罔</strong>，<strong>思而不学则殆</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WY</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WY</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
